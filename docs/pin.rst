Input/Output Pins
*****************

.. py:module:: microbit

The pins are your board's way to communicate with external devices connected to
it. There are 19 pins for your disposal, numbered 0-16 and 19-20. Pins 17 and
18 are not available. There is also a ``pin_logo`` **V2** and ``pin_speaker``
**V2** available to use with the latest micro:bit device.

For example, the script below will change the display on the micro:bit
depending upon the digital reading on pin 0::

    from microbit import *


    while True:
        if pin0.read_digital():
            display.show(Image.HAPPY)
        else:
            display.show(Image.SAD)


Pin Functions
=============

`Edge connector and pinout <https://tech.microbit.org/hardware/edgeconnector/#edge-connector-pins>`_

Those pins are available as attributes on the ``microbit``
module:``microbit.pin0`` - ``microbit.pin20``.

+-----+---------+----------+-----------------+
| Pin | Type    | Function | Function **V2** |
+=====+=========+==========+=================+
|  0  | Touch   | Pad 0    | Pad 0           |
+-----+---------+----------+-----------------+
|  1  | Touch   | Pad 1    | Pad 1           |
+-----+---------+----------+-----------------+
|  2  | Touch   | Pad 2    | Pad 2           |
+-----+---------+----------+-----------------+
|  3  | Analog  | Column 1 | Column 3        |
+-----+---------+----------+-----------------+
|  4  | Analog  | Column 2 | Column 1        |
+-----+---------+----------+-----------------+
|  5  | Digital | Button A | Button A        |
+-----+---------+----------+-----------------+
|  6  | Digital | Column 9 | Column 4        |
+-----+---------+----------+-----------------+
|  7  | Digital | Column 8 | Column 2        |
+-----+---------+----------+-----------------+
|  8  | Digital |          |                 |
+-----+---------+----------+-----------------+
|  9  | Digital | Column 7 |                 |
+-----+---------+----------+-----------------+
|  10 | Analog  | Column 3 | Column 5        |
+-----+---------+----------+-----------------+
|  11 | Digital | Button B | Button B        |
+-----+---------+----------+-----------------+
|  12 | Digital |          |                 |
+-----+---------+----------+-----------------+
|  13 | Digital | SPI SCK  | SPI SCK         |
+-----+---------+----------+-----------------+
|  14 | Digital | SPI MISO | SPI MISO        |
+-----+---------+----------+-----------------+
|  15 | Digital | SPI MOSI | SPI MOSI        |
+-----+---------+----------+-----------------+
|  16 | Digital |          |                 |
+-----+---------+----------+-----------------+
+-----+---------+----------+-----------------+
|  19 | Digital | I2C SCL  | I2C SCL         |
+-----+---------+----------+-----------------+
|  20 | Digital | I2C SDA  | I2C SDA         |
+-----+---------+----------+-----------------+

The above table summarizes the pins available, their types (see below) and what
they are internally connected to.

The latest micro:bit device **V2** has two additional pins that you can access
in MicroPython, but that are not available via the edge connector:

* ``pin_logo`` - A touch sensitive logo pin on the front of the micro:bit,
  which by default is set to capacitive touch mode.

* ``pin_speaker`` - A pin to address the micro:bit speaker.


Pulse-Width Modulation
----------------------

The pins of your board cannot output analog signal the way an audio amplifier
can do it -- by modulating the voltage on the pin. Those pins can only either
enable the full 3.3V output, or pull it down to 0V. However, it is still
possible to control the brightness of LEDs or speed of an electric motor, by
switching that voltage on and off very fast, and controlling how long it is on
and how long it is off. This technique is called Pulse-Width Modulation (PWM),
and that's what the ``write_analog`` method below does.

.. image:: pwm.png

Above you can see the diagrams of three different PWM signals. All of them have
the same period (and thus frequency), but they have different duty cycles.

The first one would be generated by ``write_analog(511)``, as it has exactly
50% duty -- the power is on half of the time, and off half of the time. The
result of that is that the total energy of this signal is the same, as if it
was 1.65V instead of 3.3V.

The second signal has 25% duty cycle, and could be generated with
``write_analog(255)``. It has similar effect as if 0.825V was being output on
that pin.

The third signal has 75% duty cycle, and can be generated with
``write_analog(767)``. It has three times as much energy, as the second signal,
and is equivalent to outputting 2.475V on th pin.

Note that this works well with devices such as motors, which have huge inertia
by themselves, or LEDs, which blink too fast for the human eye to see the
difference, but will not work so good with generating sound waves. This board
can only generate square wave sounds on itself, which sound pretty much like
the very old computer games -- mostly because those games also only could do
that.


Classes
=======

There are three kinds of pins, differing in what is available for them. They
are represented by the classes listed below. Note that they form a hierarchy,
so that each class has all the functionality of the previous class, and adds
its own to that.

.. note::
    Those classes are not actually available for the user, you can't create
    new instances of them. You can only use the instances already provided,
    representing the physical pins on your board.

.. py:class:: MicroBitDigitalPin

    .. py:method:: read_digital()

        Return 1 if the pin is high, and 0 if it's low.

    .. py:method:: write_digital(value)

        Set the pin to high if ``value`` is 1, or to low, if it is 0.

    .. py:method::set_pull(value)

        Set the pull state to one of three possible values: ``pin.PULL_UP``,
        ``pin.PULL_DOWN`` or ``pin.NO_PULL`` (where ``pin`` is an instance of
        a pin). See below for discussion of default pull states.


    .. py:method::get_pull()

        Returns the pull configuration on a pin, which can be one of three 
        possible values: ``NO_PULL``, ``PULL_DOWN``, or ``PULL_UP``. These 
        are set using the ``set_pull()`` method or automatically configured 
        when a pin mode requires it.

    .. py:method::get_mode()

        Returns the pin mode. When a pin is used for a specific function, like 
        writing a digital value, or reading an analog value, the pin mode 
        changes. Pins can have one of the following modes: ``MODE_UNUSED``, 
        ``MODE_WRITE_ANALOG``, ``MODE_READ_DIGITAL``, ``MODE_WRITE_DIGITAL``, 
        ``MODE_DISPLAY``, ``MODE_BUTTON``, ``MODE_MUSIC``, ``MODE_AUDIO_PLAY``,
        ``MODE_TOUCH``, ``MODE_I2C``, ``MODE_SPI``.


.. py:class:: MicroBitAnalogDigitalPin

    .. py:method:: read_analog()

        Read the voltage applied to the pin, and return it as an integer
        between 0 (meaning 0V) and 1023 (meaning 3.3V).


    .. py:method:: write_analog(value)

        Output a PWM signal on the pin, with the duty cycle proportional to
        the provided ``value``. The ``value`` may be either an integer or a
        floating point number between 0 (0% duty cycle) and 1023 (100% duty).

    .. py:method:: set_analog_period(period)

        Set the period of the PWM signal being output to ``period`` in
        milliseconds. The minimum valid value is 1ms.

    .. py:method:: set_analog_period_microseconds(period)

        Set the period of the PWM signal being output to ``period`` in
        microseconds. The minimum valid value is 256Âµs.


.. py:class:: MicroBitAnalogDigitalPin

    .. py:method:: read_analog()

        Read the voltage applied to the pin, and return it as an integer
        between 0 (meaning 0V) and 1023 (meaning 3.3V).


.. py:class:: MicroBitTouchPin

    .. py:method:: is_touched()

        Return ``True`` if the pin is being touched with a finger, otherwise
        return ``False``.

        .. note::
            The default touch mode for the pins on the edge connector is 
            `resistive`. The default for the logo pin **V2** is `capacitive`.

        **Resitive touch**
        This test is done by measuring how much resistance there is between the
        pin and ground.  A low resistance gives a reading of ``True``.  To get
        a reliable reading using a finger you may need to touch the ground pin
        with another part of your body, for example your other hand.

        **Capacitive touch**
        This test is done by interacting with the electric field of a capacitor
        using a finger as a conductor. `Capacitive touch
        <https://www.allaboutcircuits.com/technical-articles/introduction-to-capacitive-touch-sensing>`_
        does not require you to make a ground connection as part of a circuit.
 
The pull mode for a pin is automatically configured when the pin changes to an
input mode. Input modes are when you call ``read_analog`` / ``read_digital`` /
``is_touched``. The default pull mode for these is, respectively, ``NO_PULL``,
``PULL_DOWN``, ``PULL_UP``. Calling ``set_pull`` will configure the pin to be
in ``read_digital`` mode with the given pull mode.


.. note::
    The micro:bit has external weak (10M) pull-ups fitted on pins
    0, 1 and 2 only, in order for the touch sensing to work.

    There are also external (10k) pull-ups fitted on pins 5 and 11, in order
    for buttons A and B to work.

    GPIO pins are also used for the display, as described in the table above.
    If you want to use these pins for another purpose, you may need to turn
    the `display off
    <https://microbit-micropython.readthedocs.io/en/latest/display.html#microbit.display.off>`_.

    See the `edge connector data sheet
    <http://tech.microbit.org/hardware/edgeconnector>`_.
